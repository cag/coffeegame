// Generated by CoffeeScript 1.9.3
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  define(['jquery', './game', './entity', './geometry', './util'], function($, game, entity, geometry, util) {
    var Layer, ObjectLayer, TileLayer, TileSet, byBottomBound, byLeftBound, layer_cache_factor, layers_cached, url_prefix, url_suffix;
    url_prefix = 'assets/';
    url_suffix = '.json';
    layers_cached = true;
    layer_cache_factor = 16;
    byLeftBound = function(ent_a, ent_b) {
      return ent_a.x + ent_a.shape.bounds_offsets[0] - ent_b.x - ent_b.shape.bounds_offsets[0];
    };
    byBottomBound = function(ent_a, ent_b) {
      return ent_a.y + ent_a.shape.bounds_offsets[3] - ent_b.y - ent_b.shape.bounds_offsets[3];
    };
    TileSet = (function() {
      function TileSet(json_data, onload) {
        var tileset;
        this.name = json_data.name;
        this.first_gid = json_data.firstgid;
        this.tile_width = json_data.tilewidth;
        this.tile_height = json_data.tileheight;
        this.margin = json_data.margin;
        this.spacing = json_data.spacing;
        this.properties = json_data.properties;
        tileset = this;
        this.image = new Image();
        this.image.onload = function() {
          var ih, iw;
          iw = this.naturalWidth;
          ih = this.naturalHeight;
          if (iw !== json_data.imagewidth || ih !== json_data.imageheight) {
            throw 'tileset ' + tileset.name + ' dimension mismatch (' + iw + 'x' + ih + ' vs ' + this.naturalWidth + 'x' + this.naturalHeight + ')';
          }
          tileset.setupTileMapping();
          return typeof onload === "function" ? onload() : void 0;
        };
        this.image.src = url_prefix + json_data.image;
        return;
      }

      TileSet.prototype.setupTileMapping = function() {
        var grabTile, i, ih, img, iw, margin, numt, numtx, numty, th, thps, tw, twps;
        img = this.image;
        iw = img.naturalWidth;
        ih = img.naturalHeight;
        tw = this.tile_width;
        th = this.tile_height;
        margin = this.margin;
        twps = tw + this.spacing;
        thps = th + this.spacing;
        numtx = ((iw - margin) / twps) | 0;
        numty = ((ih - margin) / thps) | 0;
        this.num_tiles = numt = numtx * numty;
        grabTile = function(xiter, yiter) {
          var sx, sy, tcanvas, tctx;
          tcanvas = document.createElement('canvas');
          tcanvas.width = tw;
          tcanvas.height = th;
          sx = margin + xiter * twps;
          sy = margin + yiter * thps;
          tctx = tcanvas.getContext('2d');
          tctx.drawImage(img, sx, sy, tw, th, 0, 0, tw, th);
          return tcanvas;
        };
        this.tiles = (function() {
          var m, ref, results;
          results = [];
          for (i = m = 0, ref = numt; 0 <= ref ? m < ref : m > ref; i = 0 <= ref ? ++m : --m) {
            results.push(grabTile(i % numtx, (i / numtx) | 0));
          }
          return results;
        })();
      };

      TileSet.prototype.hasGID = function(gid) {
        return (this.first_gid <= gid && gid < this.first_gid + this.num_tiles);
      };

      TileSet.prototype.drawTile = function(context, gid, flip_h, flip_v, flip_d, x, y) {
        var idx, th, tw;
        idx = gid - this.first_gid;
        tw = this.tile_width;
        th = this.tile_height;
        context.save();
        context.translate(x, y);
        if (flip_h) {
          context.transform(-1, 0, 0, 1, tw, 0);
        }
        if (flip_v) {
          context.transform(1, 0, 0, -1, 0, th);
        }
        if (flip_d) {
          context.transform(0, 1, 1, 0, 0, 0);
        }
        context.drawImage(this.tiles[idx], 0, 0);
        context.restore();
      };

      return TileSet;

    })();
    Layer = (function() {
      function Layer(json_data, map1) {
        this.map = map1;
        this.name = json_data.name;
        this.type = json_data.type;
        this.properties = json_data.properties;
        this.visible = json_data.visible;
        this.opacity = json_data.opacity;
        this.x = json_data.x;
        this.y = json_data.y;
        this.width = json_data.width;
        this.height = json_data.height;
        return;
      }

      return Layer;

    })();
    TileLayer = (function(superClass) {
      extend(TileLayer, superClass);

      function TileLayer(json_data, map) {
        var height, i, j, parseGID, ref, width;
        TileLayer.__super__.constructor.call(this, json_data, map);
        if (this.type !== 'tilelayer') {
          throw "can't construct TileLayer from " + this.type + " layer";
        }
        parseGID = function(gid) {
          var flip_d, flip_h, flip_v;
          flip_h = false;
          if (gid > 2147483648) {
            flip_h = true;
            gid -= 2147483648;
          }
          flip_v = gid & 1073741824 ? true : false;
          flip_d = gid & 536870912 ? true : false;
          gid &= ~1610612736;
          return [gid, flip_h, flip_v, flip_d];
        };
        width = this.width;
        height = this.height;
        this.data = (function() {
          var m, ref, results;
          results = [];
          for (i = m = 0, ref = width; 0 <= ref ? m < ref : m > ref; i = 0 <= ref ? ++m : --m) {
            results.push((function() {
              var n, ref1, results1;
              results1 = [];
              for (j = n = 0, ref1 = height; 0 <= ref1 ? n < ref1 : n > ref1; j = 0 <= ref1 ? ++n : --n) {
                results1.push(parseGID(json_data.data[i + j * width]));
              }
              return results1;
            })());
          }
          return results;
        })();
        if (((ref = this.properties) != null ? ref.parallax : void 0) != null) {
          this.parallax = +this.properties.parallax;
        } else {
          this.parallax = 1;
        }
        return;
      }

      TileLayer.prototype.buildCache = function() {
        var cacheBlock, ch, cw, h, i, j, layer, lcf, th, tw, w;
        layer = this;
        lcf = layer_cache_factor;
        w = this.width;
        h = this.height;
        tw = this.map.tilewidth;
        th = this.map.tileheight;
        this.cache_width = cw = Math.ceil(w / lcf);
        this.cache_height = ch = Math.ceil(h / lcf);
        cacheBlock = function(bi, bj) {
          var canvas, context, nbx, nby;
          nbx = Math.min(lcf, w - bi);
          nby = Math.min(lcf, h - bj);
          canvas = document.createElement('canvas');
          canvas.width = tw * nbx;
          canvas.height = th * nby;
          context = canvas.getContext('2d');
          layer.drawRaw(context, bi, bi + nbx, bj, bj + nby, 0, 0);
          return canvas;
        };
        this.cache = (function() {
          var m, ref, results;
          results = [];
          for (i = m = 0, ref = cw; m < ref; i = m += 1) {
            results.push((function() {
              var n, ref1, results1;
              results1 = [];
              for (j = n = 0, ref1 = ch; n < ref1; j = n += 1) {
                results1.push(cacheBlock(i * lcf, j * lcf));
              }
              return results1;
            })());
          }
          return results;
        })();
      };

      TileLayer.prototype.drawRaw = function(context, lowtx, hightx, lowty, highty, dx, dy) {
        var data, datum, i, j, m, map, n, ref, ref1, ref2, ref3, th, tw;
        map = this.map;
        tw = map.tilewidth;
        th = map.tileheight;
        data = this.data;
        for (i = m = ref = lowtx, ref1 = hightx; m < ref1; i = m += 1) {
          for (j = n = ref2 = lowty, ref3 = highty; n < ref3; j = n += 1) {
            datum = data[i][j];
            map.drawTile(context, datum[0], datum[1], datum[2], datum[3], dx + (i - lowtx) * tw, dy + (j - lowty) * th);
          }
        }
      };

      TileLayer.prototype.draw = function(context, targx, targy) {
        var bh, bw, cache, cam, cambounds, destx, desty, h, highbx, highby, hightx, highty, i, j, lcf, lowbx, lowby, lowtx, lowty, m, map, mlcamxwp, mlcamywp, mlsx, mlsy, n, ref, ref1, ref2, ref3, th, tw, w;
        map = this.map;
        cam = map.camera;
        cambounds = cam.shape.bounds_offsets;
        tw = map.tilewidth;
        th = map.tileheight;
        mlcamxwp = cam.x * this.parallax - this.x * tw;
        mlcamywp = cam.y * this.parallax - this.y * th;
        w = cambounds[1] - cambounds[0];
        h = cambounds[3] - cambounds[2];
        destx = targx - mlcamxwp;
        desty = targy - mlcamywp;
        mlsx = mlcamxwp + cambounds[0];
        mlsy = mlcamywp + cambounds[2];
        context.save();
        context.beginPath();
        cam.shapeSubpath(context, targx - cam.x, targy - cam.y);
        context.clip();
        context.globalAlpha *= this.opacity;
        if (layers_cached) {
          cache = this.cache;
          lcf = layer_cache_factor;
          bw = tw * lcf;
          bh = th * lcf;
          lowbx = Math.max(0, (mlsx / bw) | 0);
          highbx = Math.min(this.cache_width, Math.ceil((mlsx + w) / bw));
          lowby = Math.max(0, (mlsy / bh) | 0);
          highby = Math.min(this.cache_height, Math.ceil((mlsy + h) / bh));
          for (i = m = ref = lowbx, ref1 = highbx; m < ref1; i = m += 1) {
            for (j = n = ref2 = lowby, ref3 = highby; n < ref3; j = n += 1) {
              context.drawImage(cache[i][j], (.5 + destx + i * bw) | 0, (.5 + desty + j * bh) | 0);
            }
          }
        } else {
          lowtx = Math.max(0, (mlsx / tw) | 0);
          hightx = Math.min(this.width, Math.ceil((mlsx + w) / tw));
          lowty = Math.max(0, (mlsy / th) | 0);
          highty = Math.min(this.height, Math.ceil((mlsy + h) / th));
          this.drawRaw(context, lowtx, hightx, lowty, highty, (.5 + destx + lowtx * tw) | 0, (.5 + desty + lowty * th) | 0);
        }
        context.restore();
      };

      return TileLayer;

    })(Layer);
    ObjectLayer = (function(superClass) {
      extend(ObjectLayer, superClass);

      function ObjectLayer(json_data, map) {
        var Aabb, Entity, Point, Polygon, Polyline, constructBitmask, ent, i, l_collides, l_obstructs, l_onCollide, l_onObstruct, len, m, mapents, n, object, objects, objh, objhwx, objhwy, objw, objx, objy, point, point_a, point_b, ref, ref1, ref2, ref3, ref4, ref5, setupEntityWithProperties, tryGettingCallbackForName, tryMakingBitmaskFromString;
        tryMakingBitmaskFromString = function(bitmask_str) {
          if (bitmask_str != null) {
            return constructBitmask(bitmask_str.split(','));
          }
          return 0;
        };
        tryGettingCallbackForName = function(name) {
          var callback;
          if (name != null) {
            callback = map.script[name];
            if (callback != null) {
              return callback;
            } else {
              throw "missing callback " + name + "!";
            }
          }
          return null;
        };
        Point = geometry.Point, Aabb = geometry.Aabb, Polyline = geometry.Polyline, Polygon = geometry.Polygon;
        Entity = entity.Entity;
        constructBitmask = util.constructBitmask;
        ObjectLayer.__super__.constructor.call(this, json_data, map);
        if (this.type !== 'objectgroup') {
          throw "can't construct ObjectLayer from " + this.type + " layer";
        }
        objects = json_data.objects;
        this.entities = [];
        mapents = map.entities;
        l_collides = tryMakingBitmaskFromString((ref = this.properties) != null ? ref.collides : void 0);
        l_onCollide = tryGettingCallbackForName((ref1 = this.properties) != null ? ref1.onCollide : void 0);
        l_obstructs = tryMakingBitmaskFromString((ref2 = this.properties) != null ? ref2.obstructs : void 0);
        l_onObstruct = tryGettingCallbackForName((ref3 = this.properties) != null ? ref3.onObstruct : void 0);
        setupEntityWithProperties = function(ent, object) {
          var obj_collides, obj_obstructs, obj_onCollide, obj_onObstruct, ref4, ref5, ref6, ref7, ref8;
          ent.onStart = tryGettingCallbackForName((ref4 = object.properties) != null ? ref4.onStart : void 0);
          obj_onCollide = tryGettingCallbackForName((ref5 = object.properties) != null ? ref5.onCollide : void 0);
          if (obj_onCollide != null) {
            ent.onCollide = obj_onCollide;
          } else {
            ent.onCollide = l_onCollide;
          }
          obj_onObstruct = tryGettingCallbackForName((ref6 = object.properties) != null ? ref6.onObstruct : void 0);
          if (obj_onObstruct != null) {
            ent.onObstruct = obj_onObstruct;
          } else {
            ent.onObstruct = l_onObstruct;
          }
          ent["static"] = true;
          obj_collides = tryMakingBitmaskFromString((ref7 = object.properties) != null ? ref7.collides : void 0);
          ent.collides = l_collides | obj_collides;
          obj_obstructs = tryMakingBitmaskFromString((ref8 = object.properties) != null ? ref8.obstructs : void 0);
          ent.obstructs = l_obstructs | obj_obstructs;
        };
        for (m = 0, len = objects.length; m < len; m++) {
          object = objects[m];
          objx = object.x;
          objy = object.y;
          objw = object.width;
          objh = object.height;
          if (object.polygon != null) {
            ent = new Entity(objx, objy, new Polygon((function() {
              var len1, n, ref4, results;
              ref4 = object.polygon;
              results = [];
              for (n = 0, len1 = ref4.length; n < len1; n++) {
                point = ref4[n];
                results.push([point.x, point.y]);
              }
              return results;
            })()));
          } else if (object.polyline != null) {
            for (i = n = 0, ref4 = object.polyline.length - 1; n < ref4; i = n += 1) {
              point_a = object.polyline[i];
              point_b = object.polyline[i + 1];
              ent = new Entity(objx, objy, new Polygon([[point_a.x, point_a.y], [point_b.x, point_b.y]]));
              setupEntityWithProperties(ent, object);
              this.addEntity(ent);
            }
            continue;
          } else if (objw === 0 && objh === 0) {
            ent = new Entity(objx, objy, new Point);
          } else {
            objhwx = .5 * objw;
            objhwy = .5 * objh;
            ent = new Entity(objx + objhwx, objy + objhwy, new Aabb([objhwx, objhwy]));
          }
          setupEntityWithProperties(ent, object);
          this.addEntity(ent);
        }
        this.entities.sort(byBottomBound);
        this.onStart = tryGettingCallbackForName((ref5 = this.properties) != null ? ref5.onStart : void 0);
        return;
      }

      ObjectLayer.prototype.addEntity = function(ent) {
        ent.layer = this;
        ent.map = this.map;
        this.entities.push(ent);
        return this.map.entities.push(ent);
      };

      ObjectLayer.prototype.draw = function(context, targx, targy) {
        var cam, ent, ents, len, m, map, xoff, yoff;
        map = this.map;
        cam = map.camera;
        xoff = targx - cam.x - this.x * map.tilewidth;
        yoff = targy - cam.y - this.y * map.tileheight;
        ents = this.entities;
        util.persistentSort(ents, byBottomBound);
        for (m = 0, len = ents.length; m < len; m++) {
          ent = ents[m];
          if (typeof ent.draw === "function") {
            ent.draw(context, xoff, yoff);
          }
        }
      };

      ObjectLayer.prototype.debugDraw = function(context, targx, targy) {
        var cam, cambounds, camlx, camly, destx, desty, ent, h, len, m, map, ref, w, xoff, yoff;
        map = this.map;
        cam = map.camera;
        cambounds = cam.shape.bounds_offsets;
        camlx = cam.x + cambounds[0];
        camly = cam.y + cambounds[2];
        w = cambounds[1] - cambounds[0];
        h = cambounds[3] - cambounds[2];
        destx = targx + cambounds[0];
        desty = targy + cambounds[2];
        xoff = destx - camlx - this.x * this.map.tilewidth;
        yoff = desty - camly - this.y * this.map.tileheight;
        context.save();
        context.beginPath();
        context.globalAlpha *= .75;
        ref = this.entities;
        for (m = 0, len = ref.length; m < len; m++) {
          ent = ref[m];
          if (ent.boundsIntersects(cam)) {
            ent.shapeSubpath(context, xoff, yoff);
          }
        }
        context.stroke();
        context.restore();
      };

      return ObjectLayer;

    })(Layer);
    return {
      Map: (function() {
        function _Class(name1, script, onload) {
          var cb_target;
          this.name = name1;
          this.script = script;
          this.loaded = false;
          this.entities = [];
          cb_target = this;
          $.getJSON(url_prefix + this.name + url_suffix, (function(data) {
            cb_target.load(data, onload);
          }));
          return;
        }

        _Class.prototype.load = function(json_data, onload) {
          var createLayer, l, map, tileset_load_count, tileset_load_total, tilesets, ts, ts_load_cb;
          if (json_data.orientation !== 'orthogonal') {
            throw "orientation " + orientation + " not supported";
          }
          this.width = json_data.width;
          this.height = json_data.height;
          this.tilewidth = json_data.tilewidth;
          this.tileheight = json_data.tileheight;
          this.orientation = json_data.orientation;
          this.properties = json_data.properties;
          map = this;
          createLayer = function(data) {
            var type;
            type = data.type;
            if (type === 'tilelayer') {
              return new TileLayer(data, map);
            } else if (type === 'objectgroup') {
              return new ObjectLayer(data, map);
            } else {
              console.warn("unknown layer type " + type + " requested");
              return new Layer(data, map);
            }
          };
          this.layers = (function() {
            var len, m, ref, results;
            ref = json_data.layers;
            results = [];
            for (m = 0, len = ref.length; m < len; m++) {
              l = ref[m];
              results.push(createLayer(l));
            }
            return results;
          })();
          tilesets = json_data.tilesets;
          tileset_load_total = tilesets.length;
          tileset_load_count = 0;
          ts_load_cb = function() {
            if (++tileset_load_count >= tileset_load_total) {
              if (layers_cached) {
                map.buildLayerCaches();
              }
              map.loaded = true;
              if (typeof onload === "function") {
                onload();
              }
            }
          };
          this.tilesets = (function() {
            var len, m, results;
            results = [];
            for (m = 0, len = tilesets.length; m < len; m++) {
              ts = tilesets[m];
              results.push(new TileSet(ts, ts_load_cb));
            }
            return results;
          })();
          this.entities.sort(byLeftBound);
        };

        _Class.prototype.buildLayerCaches = function() {
          var layer, len, m, ref;
          ref = this.layers;
          for (m = 0, len = ref.length; m < len; m++) {
            layer = ref[m];
            if (layer.type === 'tilelayer') {
              layer.buildCache();
            }
          }
        };

        _Class.prototype.drawTile = function(context, gid, flip_h, flip_v, flip_d, x, y) {
          var len, m, ref, tileset;
          ref = this.tilesets;
          for (m = 0, len = ref.length; m < len; m++) {
            tileset = ref[m];
            if (tileset.hasGID(gid)) {
              tileset.drawTile(context, gid, flip_h, flip_v, flip_d, x, y);
              break;
            }
          }
        };

        _Class.prototype.doCollisions = function() {
          var enti, ents, i, j, k, m, n, ref, ref1, ref2;
          ents = this.entities;
          util.persistentSort(ents, byLeftBound);
          j = 0;
          for (i = m = 1, ref = ents.length; m < ref; i = m += 1) {
            enti = this.entities[i];
            while (j < i && ents[j].x + ents[j].shape.bounds_offsets[1] < enti.x + enti.shape.bounds_offsets[0]) {
              ++j;
            }
            for (k = n = ref1 = j, ref2 = i; n < ref2; k = n += 1) {
              this.doCollision(enti, this.entities[k]);
            }
          }
        };

        _Class.prototype.doCollision = function(ent_a, ent_b) {
          var can_collide, can_obstruct, collision_info, neg_collision_info, notrat, pen_amt, pen_dir, proj_x, proj_y, rat;
          if (ent_a["static"] && ent_b["static"]) {
            return;
          }
          can_collide = ent_a.collides & ent_b.collides;
          can_obstruct = ent_a.obstructs & ent_b.obstructs;
          if (!(can_collide || can_obstruct)) {
            return;
          }
          collision_info = ent_a.intersects(ent_b);
          if (collision_info) {
            pen_amt = collision_info[0], pen_dir = collision_info[1];
            neg_collision_info = [pen_amt, [-pen_dir[0], -pen_dir[1]]];
            if (typeof ent_a.onCollide === "function") {
              ent_a.onCollide(ent_b, collision_info);
            }
            if (typeof ent_b.onCollide === "function") {
              ent_b.onCollide(ent_a, neg_collision_info);
            }
            if (can_obstruct) {
              proj_x = pen_amt * pen_dir[0];
              proj_y = pen_amt * pen_dir[1];
              if (ent_a["static"]) {
                ent_b.x += proj_x;
                ent_b.y += proj_y;
              } else if (ent_b["static"]) {
                ent_a.x -= proj_x;
                ent_a.y -= proj_y;
              } else {
                rat = .5;
                notrat = 1 - rat;
                ent_a.x -= rat * proj_x;
                ent_a.y -= rat * proj_y;
                ent_b.x += notrat * proj_x;
                ent_b.y += notrat * proj_y;
              }
              if (typeof ent_a.onObstruct === "function") {
                ent_a.onObstruct(ent_b, collision_info);
              }
              if (typeof ent_b.onObstruct === "function") {
                ent_b.onObstruct(ent_a, neg_collision_info);
              }
            }
          }
        };

        _Class.prototype.start = function() {
          var ent, layer, len, len1, m, n, ref, ref1;
          ref = this.layers;
          for (m = 0, len = ref.length; m < len; m++) {
            layer = ref[m];
            if (typeof layer.onStart === "function") {
              layer.onStart(layer);
            }
          }
          ref1 = this.entities;
          for (n = 0, len1 = ref1.length; n < len1; n++) {
            ent = ref1[n];
            if (typeof ent.onStart === "function") {
              ent.onStart(ent);
            }
          }
        };

        _Class.prototype.update = function(dt) {
          var base, ent, len, m, ref;
          ref = this.entities;
          for (m = 0, len = ref.length; m < len; m++) {
            ent = ref[m];
            if (typeof ent.update === "function") {
              ent.update(dt);
            }
          }
          this.doCollisions();
          if (typeof (base = this.camera).post_update === "function") {
            base.post_update(dt);
          }
        };

        _Class.prototype.draw = function(context, targx, targy) {
          var layer, len, m, ref;
          ref = this.layers;
          for (m = 0, len = ref.length; m < len; m++) {
            layer = ref[m];
            layer.draw(context, targx, targy);
          }
        };

        _Class.prototype.debugDraw = function(context, targx, targy) {
          var cam, ent, found_first, i, layer, len, m, n, ref, ref1, xoff, yoff;
          cam = this.camera;
          xoff = targx - cam.x;
          yoff = targy - cam.y;
          found_first = false;
          for (i = m = 0, ref = this.entities.length; m < ref; i = m += 1) {
            ent = this.entities[i];
            if (ent.boundsIntersects(cam)) {
              ent.shapeSubpath(context, xoff, yoff);
              found_first = true;
            } else if (found_first && cam.boundsLeftOf(ent)) {
              break;
            }
          }
          ref1 = this.layers;
          for (n = 0, len = ref1.length; n < len; n++) {
            layer = ref1[n];
            if (layer.type === 'objectgroup') {
              layer.debugDraw(context, targx, targy);
            }
          }
        };

        return _Class;

      })(),
      MapScene: (function() {
        function _Class(map1) {
          this.map = map1;
          return;
        }

        _Class.prototype.start = function() {
          var Aabb, Entity;
          if (!this.map.loaded) {
            throw this.map.name + " not loaded!";
          }
          Entity = entity.Entity;
          Aabb = geometry.Aabb;
          this.map.camera = new Entity(0, 0, new Aabb([.5 * game.width(), .5 * game.height()]));
          this.map.entities.push(this.map.camera);
          this.map.start();
        };

        _Class.prototype.end = function() {};

        _Class.prototype.update = function(dt) {
          this.map.update(dt);
        };

        _Class.prototype.draw = function(context) {
          var gh, gw, hgh, hgw;
          gw = game.width();
          gh = game.height();
          hgw = .5 * gw;
          hgh = .5 * gh;
          context.clearRect(0, 0, gw, gh);
          context.beginPath();
          this.map.draw(context, hgw, hgh);
        };

        return _Class;

      })()
    };
  });

}).call(this);
