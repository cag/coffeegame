// Generated by CoffeeScript 1.3.3
(function() {

  define(function() {
    var EPSILON, NORMAL_LENGTH, NORMAL_OFFSET, POINT_RADIUS, calcPolyBounds, calcShapePolygonMinimumPenetrationVector, dotProduct, intersection_test_map, intervalsIntersect, normalize, projectShapeOntoAxis, testAabbAabbIntersection, testAabbPolygonIntersection, testPointAabbIntersection, testPointPointIntersection, testPointPolygonIntersection, testPolygonPolygonIntersection;
    POINT_RADIUS = 2;
    NORMAL_OFFSET = 4;
    NORMAL_LENGTH = 2;
    EPSILON = Math.pow(2, -50);
    dotProduct = function(u, v) {
      return u[0] * v[0] + u[1] * v[1];
    };
    normalize = function(v) {
      var invnorm;
      invnorm = 1 / Math.sqrt(dotProduct(v, v));
      return [invnorm * v[0], invnorm * v[1]];
    };
    projectShapeOntoAxis = function(shape, axis) {
      var hw_proj, max, min, point, pt_proj, pts, stype, _i, _len;
      min = Number.POSITIVE_INFINITY;
      max = Number.NEGATIVE_INFINITY;
      stype = shape.type;
      if (stype === 'Point') {
        min = 0;
        max = 0;
      } else if (stype === 'Aabb') {
        hw_proj = dotProduct(shape.halfwidth, axis);
        if (hw_proj < 0) {
          min = Math.min(min, hw_proj);
          max = Math.max(max, -hw_proj);
        } else {
          min = Math.min(min, -hw_proj);
          max = Math.max(max, hw_proj);
        }
        hw_proj = dotProduct([shape.halfwidth[0], -shape.halfwidth[1]], axis);
        if (hw_proj < 0) {
          min = Math.min(min, hw_proj);
          max = Math.max(max, -hw_proj);
        } else {
          min = Math.min(min, -hw_proj);
          max = Math.max(max, hw_proj);
        }
      } else if (stype === 'Polygon') {
        pts = shape.points;
        for (_i = 0, _len = pts.length; _i < _len; _i++) {
          point = pts[_i];
          pt_proj = dotProduct(point, axis);
          min = Math.min(min, pt_proj);
          max = Math.max(max, pt_proj);
        }
      }
      return [min, max];
    };
    intervalsIntersect = function(a, b) {
      var aoff, boff;
      if (a[1] < b[0] || b[1] < a[0]) {
        return false;
      }
      aoff = b[1] - a[0];
      boff = a[1] - b[0];
      if (aoff < boff) {
        return -aoff;
      }
      return boff;
    };
    calcShapePolygonMinimumPenetrationVector = function(s, sx, sy, p, px, py, pen_amt, pen_dir, negate) {
      var abs_intersects, i, intersects, normal, p_bounds, proj_p_pos, proj_s_pos, s_bounds, _i, _ref;
      if (pen_amt == null) {
        pen_amt = Number.POSITIVE_INFINITY;
      }
      if (negate == null) {
        negate = false;
      }
      for (i = _i = 0, _ref = p.normals.length; _i < _ref; i = _i += 1) {
        normal = p.normals[i];
        p_bounds = p.bounds_on_normals[i];
        proj_s_pos = dotProduct([sx, sy], normal);
        proj_p_pos = dotProduct([px, py], normal);
        s_bounds = projectShapeOntoAxis(s, normal);
        intersects = intervalsIntersect([s_bounds[0] + proj_s_pos, s_bounds[1] + proj_s_pos], [p_bounds[0] + proj_p_pos, p_bounds[1] + proj_p_pos]);
        if (!intersects) {
          return false;
        }
        abs_intersects = Math.abs(intersects);
        if (abs_intersects < pen_amt) {
          pen_amt = abs_intersects;
          if (negate === (intersects < 0)) {
            pen_dir = normal;
          } else {
            pen_dir = [-normal[0], -normal[1]];
          }
        }
      }
      return [pen_amt, pen_dir];
    };
    calcPolyBounds = function(points) {
      var maxx, maxy, minx, miny, point, _i, _len;
      minx = points[0][0];
      maxx = points[0][0];
      miny = points[0][1];
      maxy = points[0][1];
      for (_i = 0, _len = points.length; _i < _len; _i++) {
        point = points[_i];
        minx = Math.min(minx, point[0]);
        maxx = Math.max(maxx, point[0]);
        miny = Math.min(miny, point[1]);
        maxy = Math.max(maxy, point[1]);
      }
      return [minx, maxx, miny, maxy];
    };
    testPointPointIntersection = function(p1, p1x, p1y, p2, p2x, p2y) {
      return [0, [1, 0]];
    };
    testPointAabbIntersection = function(p, px, py, a, ax, ay) {
      var next_proj, pen_amt, pen_dir;
      pen_amt = ax + a.halfwidth[0] - px;
      pen_dir = [-1, 0];
      next_proj = ay + a.halfwidth[1] - py;
      if (next_proj < pen_amt) {
        pen_amt = next_proj;
        pen_dir = [0, -1];
      }
      next_proj = px - (ax - a.halfwidth[0]);
      if (next_proj < pen_amt) {
        pen_amt = next_proj;
        pen_dir = [1, 0];
      }
      next_proj = py - (ay - a.halfwidth[1]);
      if (next_proj < pen_amt) {
        pen_amt = next_proj;
        pen_dir = [0, 1];
      }
      return [pen_amt, pen_dir];
    };
    testPointPolygonIntersection = function(p1, p1x, p1y, p2, p2x, p2y) {
      return calcShapePolygonMinimumPenetrationVector(p1, p1x, p1y, p2, p2x, p2y);
    };
    testAabbAabbIntersection = function(a1, a1x, a1y, a2, a2x, a2y) {
      var next_proj, pen_amt, pen_dir;
      pen_amt = a2x + a2.halfwidth[0] - (a1x - a1.halfwidth[0]);
      pen_dir = [-1, 0];
      next_proj = a2y + a2.halfwidth[1] - (a1y - a1.halfwidth[1]);
      if (next_proj < pen_amt) {
        pen_amt = next_proj;
        pen_dir = [0, -1];
      }
      next_proj = a1x + a1.halfwidth[0] - (a2x - a2.halfwidth[0]);
      if (next_proj < pen_amt) {
        pen_amt = next_proj;
        pen_dir = [1, 0];
      }
      next_proj = a1y + a1.halfwidth[1] - (a2y - a2.halfwidth[1]);
      if (next_proj < pen_amt) {
        pen_amt = next_proj;
        pen_dir = [0, 1];
      }
      return [pen_amt, pen_dir];
    };
    testAabbPolygonIntersection = function(a, ax, ay, p, px, py) {
      var intersects, pen_amt, pen_dir;
      intersects = intervalsIntersect([ax + a.bounds_offsets[0], ax + a.bounds_offsets[1]], [px + p.bounds_offsets[0], px + p.bounds_offsets[1]]);
      if (intersects < 0) {
        pen_amt = -intersects;
        pen_dir = [-1, 0];
      } else {
        pen_amt = intersects;
        pen_dir = [1, 0];
      }
      intersects = intervalsIntersect([ay + a.bounds_offsets[2], ay + a.bounds_offsets[3]], [py + p.bounds_offsets[2], py + p.bounds_offsets[3]]);
      if (intersects < 0) {
        pen_amt = -intersects;
        pen_dir = [0, -1];
      } else {
        pen_amt = intersects;
        pen_dir = [0, 1];
      }
      return calcShapePolygonMinimumPenetrationVector(a, ax, ay, p, px, py, pen_amt, pen_dir);
    };
    testPolygonPolygonIntersection = function(p1, p1x, p1y, p2, p2x, p2y) {
      var pen_amt, pen_dir, ret;
      ret = calcShapePolygonMinimumPenetrationVector(p1, p1x, p1y, p2, p2x, p2y);
      if (ret) {
        pen_amt = ret[0], pen_dir = ret[1];
      } else {
        return false;
      }
      return calcShapePolygonMinimumPenetrationVector(p2, p2x, p2y, p1, p1x, p1y, pen_amt, pen_dir, true);
    };
    intersection_test_map = {
      Point: {
        Point: testPointPointIntersection,
        Aabb: testPointAabbIntersection,
        Polygon: testPointPolygonIntersection
      },
      Aabb: {
        Aabb: testAabbAabbIntersection,
        Polygon: testAabbPolygonIntersection
      },
      Polygon: {
        Polygon: testPolygonPolygonIntersection
      }
    };
    return {
      dotProduct: dotProduct,
      Point: (function() {

        function _Class() {
          this.type = 'Point';
          this.bounds_offsets = [0, 0, 0, 0];
        }

        _Class.prototype.subpath = function(context, offx, offy) {
          context.moveTo(offx + POINT_RADIUS, offy);
          context.arc(offx, offy, POINT_RADIUS, 0, 2 * Math.PI);
        };

        return _Class;

      })(),
      Aabb: (function() {

        function _Class(halfwidth) {
          var hw;
          this.halfwidth = halfwidth;
          this.type = 'Aabb';
          hw = this.halfwidth;
          this.bounds_offsets = [-hw[0], hw[0], -hw[1], hw[1]];
          return;
        }

        _Class.prototype.subpath = function(context, offx, offy) {
          var hw;
          hw = this.halfwidth;
          context.rect(offx - hw[0], offy - hw[1], 2 * hw[0], 2 * hw[1]);
        };

        return _Class;

      })(),
      Polygon: (function() {

        function _Class(points) {
          var bounds_on_normal, bounds_on_normals, ccw, cross, edge1, edge2, i, j, k, normal, normals, num_vertices, other, pt, ptslen, skip, sumx, sumy, _i, _j, _k, _l, _len, _len1;
          this.type = 'Polygon';
          this.bounds_offsets = calcPolyBounds(points);
          sumx = 0;
          sumy = 0;
          num_vertices = points.length;
          for (_i = 0, _len = points.length; _i < _len; _i++) {
            pt = points[_i];
            sumx += pt[0];
            sumy += pt[1];
          }
          this.center_offset = [sumx / num_vertices, sumy / num_vertices];
          ccw = null;
          ptslen = points.length;
          for (i = _j = 0; _j < ptslen; i = _j += 1) {
            j = (i + 1) % ptslen;
            k = (i + 2) % ptslen;
            edge1 = [points[j][0] - points[i][0], points[j][1] - points[i][1]];
            edge2 = [points[k][0] - points[j][0], points[k][1] - points[j][1]];
            cross = edge1[0] * edge2[1] - edge2[0] * edge1[1];
            if (ccw != null) {
              if (ccw && cross > 0 || !ccw && cross < 0) {
                throw 'tried to construct non-convex polygon';
              }
            } else {
              ccw = cross < 0;
            }
          }
          if (ccw) {
            this.points = points.reverse();
          } else {
            this.points = points;
          }
          normals = [];
          bounds_on_normals = [];
          for (i = _k = 0; _k < ptslen; i = _k += 1) {
            j = (i + 1) % ptslen;
            normal = normalize([this.points[i][1] - this.points[j][1], this.points[j][0] - this.points[i][0]]);
            skip = false;
            for (_l = 0, _len1 = normals.length; _l < _len1; _l++) {
              other = normals[_l];
              if (Math.abs(dotProduct(normal, other)) > 1 - EPSILON) {
                skip = true;
                continue;
              }
            }
            if (skip) {
              continue;
            }
            bounds_on_normal = projectShapeOntoAxis(this, normal);
            normals.push(normal);
            bounds_on_normals.push(bounds_on_normal);
          }
          this.normals = normals;
          this.bounds_on_normals = bounds_on_normals;
          return;
        }

        _Class.prototype.subpath = function(context, offx, offy) {
          var coffx, coffy, i, normal, pts, _i, _j, _len, _ref, _ref1;
          pts = this.points;
          context.moveTo(pts[0][0] + offx, pts[0][1] + offy);
          for (i = _i = 1, _ref = pts.length; _i < _ref; i = _i += 1) {
            context.lineTo(pts[i][0] + offx, pts[i][1] + offy);
          }
          context.closePath();
          coffx = offx + this.center_offset[0];
          coffy = offy + this.center_offset[1];
          context.moveTo(coffx + POINT_RADIUS, coffy);
          context.arc(coffx, coffy, POINT_RADIUS, 0, 2 * Math.PI);
          _ref1 = this.normals;
          for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
            normal = _ref1[_j];
            context.moveTo(coffx + NORMAL_OFFSET * normal[0], coffy + NORMAL_OFFSET * normal[1]);
            context.lineTo(coffx + (NORMAL_LENGTH + NORMAL_OFFSET) * normal[0], coffy + (NORMAL_LENGTH + NORMAL_OFFSET) * normal[1]);
          }
        };

        return _Class;

      })(),
      intersects: function(x_a, x_b, y_a, y_b, shape_a, shape_b) {
        var result, test, _ref, _ref1;
        test = (_ref = intersection_test_map[shape_a.type]) != null ? _ref[shape_b.type] : void 0;
        if (test != null) {
          return test(shape_a, x_a, y_a, shape_b, x_b, y_b);
        } else {
          test = (_ref1 = intersection_test_map[shape_b.type]) != null ? _ref1[shape_a.type] : void 0;
          if (test != null) {
            result = test(shape_b, x_b, y_b, shape_a, x_a, y_a);
            if (result) {
              return [result[0], [-result[1][0], -result[1][1]]];
            } else {
              return false;
            }
          }
        }
        throw "can't test " + shape_a.type + " against " + shape_b.type;
        return false;
      }
    };
  });

}).call(this);
